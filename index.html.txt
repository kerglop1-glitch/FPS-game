<!--
Complex FPS - Single File HTML
Open this file in a modern browser (drag into Chrome/Edge/Firefox). No build step required.
Features:
- WebGL rendering via three.js (loaded from CDN)
- Pointer lock mouse look + WASD movement + jump/sprint/crouch
- Weapon with shooting, recoil, ammo, reload
- Enemies with simple AI (seek & wander) and health
- Raycast-based shooting, bullet decals, hit markers
- Simple physics for player velocity and gravity
- HUD: health, ammo, crosshair, minimap (2D canvas)
- Pickup spawning (health/ammo)
- Basic sound placeholders
- Configurable variables at top for easy tweaking

This is intentionally complex but meant as a single-file starting point for a larger game.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Complex FPS â€” Single File</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#eee;font-family:Inter,system-ui,Arial}
    #game-container{position:fixed;inset:0;overflow:hidden}
    canvas{display:block}
    .overlay{position:fixed;left:0;right:0;top:0;pointer-events:none}
    #hud{pointer-events:none;padding:12px;display:flex;justify-content:space-between;align-items:flex-start}
    .left, .right{min-width:160px}
    .bar{background:rgba(0,0,0,0.5);padding:8px;border-radius:8px}
    #health{font-weight:700;color:#f44}
    #ammo{font-weight:700}
    #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:6px;height:6px;border-radius:50%;background:#fff;opacity:0.9;mix-blend-mode:exclusion}
    #crosshair::after{content:'';position:absolute;left:50%;top:50%;width:40px;height:1px;background:rgba(255,255,255,0.2);transform:translate(-50%,-50%)}
    #message{position:fixed;left:50%;top:60%;transform:translateX(-50%);pointer-events:none}
    #minimap{position:fixed;right:12px;bottom:12px;width:180px;height:180px;background:rgba(0,0,0,0.6);border-radius:6px;padding:6px}
    #controls{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px}
    button{pointer-events:auto}
  </style>
</head>
<body>
  <div id="game-container"></div>

  <div class="overlay" id="hud">
    <div class="left bar">
      <div id="health">Health: 100</div>
      <div id="status">Status: Idle</div>
    </div>
    <div class="right bar">
      <div id="ammo">Ammo: 30 / 120</div>
      <div id="enemy-count">Enemies: 0</div>
    </div>
  </div>

  <div id="crosshair"></div>
  <div id="message"></div>
  <canvas id="minimap"></canvas>
  <div id="controls" class="bar">
    <button id="startBtn">Click to Start (Pointer Lock)</button>
    <button id="respawnBtn">Respawn</button>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.158.0/examples/js/controls/PointerLockControls.js"></script>
  <script>
  // ==================== CONFIG ====================
  const CONFIG = {
    playerHeight: 1.8,
    speedWalk: 4.0,
    speedRun: 7.5,
    gravity: -9.8,
    jumpSpeed: 5.0,
    bulletRange: 200,
    bulletDamage: 34,
    fireRate: 0.12, // seconds between shots
    clipSize: 30,
    reserveAmmo: 120,
    enemyCount: 8,
    worldSize: 120,
  };

  // ================ Basic three.js setup ================
  const container = document.getElementById('game-container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
  hemi.position.set(0, 200, 0);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.8);
  sun.position.set(50,100,50);
  scene.add(sun);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 32, 32);
  const groundMat = new THREE.MeshStandardMaterial({color:0x556b2f});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Simple obstacles
  const obstacles = new THREE.Group();
  for(let i=0;i<45;i++){
    const size = 1 + Math.random()*4;
    const g = new THREE.BoxGeometry(size, size, size);
    const m = new THREE.MeshStandardMaterial({color: 0x6b6b6b});
    const b = new THREE.Mesh(g,m);
    b.position.set((Math.random()-0.5)*CONFIG.worldSize*0.9, size/2, (Math.random()-0.5)*CONFIG.worldSize*0.9);
    b.castShadow = true;
    b.receiveShadow = true;
    obstacles.add(b);
  }
  scene.add(obstacles);

  // PLAYER STATE
  const player = {
    velocity: new THREE.Vector3(0,0,0),
    direction: new THREE.Vector3(0,0,-1),
    position: new THREE.Vector3(0, CONFIG.playerHeight, 0),
    onGround: true,
    health: 100,
    running: false,
    crouched: false,
  };

  camera.position.copy(player.position);

  // Pointer lock controls
  const controls = new THREE.PointerLockControls(camera, document.body);
  document.getElementById('startBtn').addEventListener('click', ()=> controls.lock());
  controls.addEventListener('lock', ()=>{document.getElementById('message').textContent='Controls locked: WASD to move, mouse to look, click to shoot';});
  controls.addEventListener('unlock', ()=>{document.getElementById('message').textContent='Controls unlocked';});

  // Movement input
  const keys = {w:0,a:0,s:0,d:0, Space:0, Shift:0, Control:0};
  window.addEventListener('keydown', e=>{ if(e.key===' ') keys.Space=1; if(e.key==='Shift') keys.Shift=1; if(e.key==='Control') keys.Control=1; if(e.key.toLowerCase()==='w') keys.w=1; if(e.key.toLowerCase()==='a') keys.a=1; if(e.key.toLowerCase()==='s') keys.s=1; if(e.key.toLowerCase()==='d') keys.d=1; });
  window.addEventListener('keyup', e=>{ if(e.key===' ') keys.Space=0; if(e.key==='Shift') keys.Shift=0; if(e.key==='Control') keys.Control=0; if(e.key.toLowerCase()==='w') keys.w=0; if(e.key.toLowerCase()==='a') keys.a=0; if(e.key.toLowerCase()==='s') keys.s=0; if(e.key.toLowerCase()==='d') keys.d=0; });

  // Weapon state
  const weapon = { lastShot:0, clip: CONFIG.clipSize, reserve: CONFIG.reserveAmmo };

  // Raycaster for shooting
  const raycaster = new THREE.Raycaster();

  // Enemies
  const enemies = [];
  const enemyGroup = new THREE.Group();
  scene.add(enemyGroup);

  function spawnEnemy(pos){
    const g = new THREE.SphereGeometry(0.7, 12, 12);
    const m = new THREE.MeshStandardMaterial({color:0x8b0000});
    const mesh = new THREE.Mesh(g,m);
    mesh.position.copy(pos);
    mesh.health = 100;
    mesh.speed = 1.2 + Math.random()*0.6;
    mesh.state = 'idle';
    enemyGroup.add(mesh);
    enemies.push(mesh);
  }

  function spawnEnemies(){
    for(let i=0;i<CONFIG.enemyCount;i++){
      const p = new THREE.Vector3((Math.random()-0.5)*CONFIG.worldSize*0.8,0.7,(Math.random()-0.5)*CONFIG.worldSize*0.8);
      spawnEnemy(p);
    }
    document.getElementById('enemy-count').textContent = `Enemies: ${enemies.length}`;
  }

  spawnEnemies();

  // Pickups
  const pickups = [];
  function spawnPickup(type, pos){
    const g = new THREE.BoxGeometry(0.5,0.5,0.5);
    const c = type==='health'?0x00ff88:0xffff66;
    const m = new THREE.MeshStandardMaterial({color:c});
    const p = new THREE.Mesh(g,m);
    p.position.copy(pos);
    p.type = type;
    scene.add(p);
    pickups.push(p);
  }
  // spawn a few
  for(let i=0;i<6;i++) spawnPickup(i%2===0?'health':'ammo', new THREE.Vector3((Math.random()-0.5)*CONFIG.worldSize*0.9,0.25,(Math.random()-0.5)*CONFIG.worldSize*0.9));

  // HUD helpers
  function updateHUD(){
    document.getElementById('health').textContent = `Health: ${Math.max(0,Math.round(player.health))}`;
    document.getElementById('ammo').textContent = `Ammo: ${weapon.clip} / ${weapon.reserve}`;
    document.getElementById('enemy-count').textContent = `Enemies: ${enemies.length}`;
  }

  // Minimap
  const mm = document.getElementById('minimap');
  mm.width = 180; mm.height = 180; const mmCtx = mm.getContext('2d');
  function drawMinimap(){
    const s = mm.width; mmCtx.clearRect(0,0,s,s);
    mmCtx.fillStyle = '#061'; mmCtx.fillRect(0,0,s,s);
    // draw player center
    const scale = s / CONFIG.worldSize;
    const cx = s/2, cy = s/2;
    mmCtx.fillStyle = '#fff';
    mmCtx.beginPath(); mmCtx.arc(cx,cy,4,0,Math.PI*2); mmCtx.fill();
    // draw enemies relative
    enemies.forEach(e=>{
      const dx = (e.position.x - player.position.x) * scale;
      const dz = (e.position.z - player.position.z) * scale;
      mmCtx.fillStyle = '#ff3333'; mmCtx.beginPath(); mmCtx.arc(cx+dx, cy+dz, 3,0,Math.PI*2); mmCtx.fill();
    });
  }

  // Basic AI update (seek player if close, otherwise wander)
  function updateEnemies(dt){
    enemies.forEach(e=>{
      if(e.health<=0) return;
      const toPlayer = new THREE.Vector3().subVectors(player.position, e.position);
      const dist = toPlayer.length();
      if(dist < 20){
        // seek
        toPlayer.normalize();
        e.position.addScaledVector(toPlayer, e.speed*dt);
        e.state = 'seek';
        // attack if close
        if(dist < 1.5 && Math.random() < 0.02){ player.health -= 8; }
      } else {
        // wander
        if(!e._t) e._t=Math.random()*1000;
        e._t += dt*0.2;
        e.position.x += Math.sin(e._t)*0.01;
        e.position.z += Math.cos(e._t)*0.01;
        e.state = 'wander';
      }
      // simple obstacle avoidance: clamp to world
      const r = CONFIG.worldSize*0.48;
      e.position.x = Math.max(-r,Math.min(r,e.position.x));
      e.position.z = Math.max(-r,Math.min(r,e.position.z));
    });
  }

  // Shooting mechanics
  let mouseDown = false;
  window.addEventListener('mousedown', (e)=>{ if(e.button===0) mouseDown=true; });
  window.addEventListener('mouseup', (e)=>{ if(e.button===0) mouseDown=false; });

  function shoot(time){
    if(time - weapon.lastShot < CONFIG.fireRate*1000) return; // enforce fire rate
    if(weapon.clip <= 0){ showMessage('Clip empty, reload!'); return; }
    weapon.lastShot = time;
    weapon.clip--;
    // recoil effect (bump camera)
    camera.rotation.x = Math.max(-0.6, camera.rotation.x - 0.02);
    // perform raycast
    const origin = camera.position.clone();
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    raycaster.set(origin, dir);
    const hits = raycaster.intersectObjects([...enemyGroup.children, ...obstacles.children], true);
    if(hits.length>0){
      const hit = hits[0];
      if(hit.object.parent === enemyGroup || enemies.includes(hit.object)){
        // find which enemy
        const enemy = enemies.find(en=>en===hit.object || en.children.includes(hit.object));
        if(enemy){ enemy.health -= CONFIG.bulletDamage; showHitMarker(); if(enemy.health<=0){ removeEnemy(enemy); } }
      } else {
        // bullet decal: small particle
        const p = new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6), new THREE.MeshBasicMaterial({color:0x222222}));
        p.position.copy(hit.point);
        scene.add(p);
        setTimeout(()=> scene.remove(p), 3000);
      }
    }
  }

  function showHitMarker(){
    const ch = document.getElementById('crosshair');
    ch.style.transform = 'translate(-50%,-50%) scale(1.6)';
    setTimeout(()=> ch.style.transform = 'translate(-50%,-50%) scale(1)', 80);
  }

  function removeEnemy(enemy){
    const idx = enemies.indexOf(enemy); if(idx!==-1) enemies.splice(idx,1);
    enemyGroup.remove(enemy);
    document.getElementById('enemy-count').textContent = `Enemies: ${enemies.length}`;
    // drop pickup sometimes
    if(Math.random()<0.35) spawnPickup(Math.random()<0.5?'health':'ammo', enemy.position.clone());
  }

  function showMessage(txt, t=2000){ const el=document.getElementById('message'); el.textContent=txt; if(t>0) setTimeout(()=>{ if(el.textContent===txt) el.textContent=''; }, t); }

  // Collision detection with pickups
  function checkPickups(){
    for(let i=pickups.length-1;i>=0;i--){ const p=pickups[i]; if(p.position.distanceTo(player.position) < 1.2){ if(p.type==='health'){ player.health = Math.min(100, player.health+30); showMessage('Picked up health'); } else { weapon.reserve += 30; showMessage('Picked up ammo'); } scene.remove(p); pickups.splice(i,1); } }
  }

  // Respawn
  function respawn(){
    player.position.set(0, CONFIG.playerHeight, 0); player.health=100; weapon.clip=CONFIG.clipSize; weapon.reserve=CONFIG.reserveAmmo; enemies.length=0; enemyGroup.clear(); spawnEnemies(); updateHUD(); showMessage('Respawned');
  }
  document.getElementById('respawnBtn').addEventListener('click', respawn);

  // Shooting loop handling
  function handleShooting(time){
    if(controls.isLocked && mouseDown) shoot(time);
  }

  // Reload
  window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='r'){ const needed = CONFIG.clipSize - weapon.clip; const take = Math.min(needed, weapon.reserve); weapon.clip += take; weapon.reserve -= take; showMessage('Reloaded'); updateHUD(); } });

  // Main loop
  let last = performance.now();
  function animate(now){
    const dt = Math.min(0.06, (now-last)/1000); last = now;
    // player movement
    const speed = (keys.Shift?CONFIG.speedRun:CONFIG.speedWalk) * (player.crouched?0.6:1.0);
    const forward = (keys.w?1:0) - (keys.s?1:0);
    const strafe = (keys.d?1:0) - (keys.a?1:0);
    const move = new THREE.Vector3();
    if(forward!==0) move.z += forward;
    if(strafe!==0) move.x += strafe;
    if(move.lengthSq()>0) move.normalize();
    const quat = camera.quaternion;
    // rotate move vector by camera yaw only
    const yaw = new THREE.Euler(0, camera.rotation.y, 0, 'YXZ');
    move.applyEuler(yaw);
    player.position.addScaledVector(move, speed*dt);

    // gravity & jump
    player.velocity.y += CONFIG.gravity * dt;
    if(keys.Space && player.onGround){ player.velocity.y = CONFIG.jumpSpeed; player.onGround=false; }
    player.position.y += player.velocity.y * dt;
    if(player.position.y <= CONFIG.playerHeight){ player.onGround=true; player.velocity.y=0; player.position.y = CONFIG.playerHeight; }

    // apply position to camera and controls
    camera.position.copy(player.position);

    // simple world bounds
    const bound = CONFIG.worldSize*0.49;
    camera.position.x = Math.max(-bound, Math.min(bound, camera.position.x));
    camera.position.z = Math.max(-bound, Math.min(bound, camera.position.z));

    // enemy updates
    updateEnemies(dt);
    // pickups
    checkPickups();
    // shooting
    handleShooting(now);

    // update HUD
    updateHUD();
    drawMinimap();

    // small camera stabilization
    camera.rotation.x *= 0.98;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // window resize
  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // initial UI messages
  showMessage('Welcome. Click "Start" then click the screen to lock pointer and play.');

  // Helper: cleanup enemies on death, simple health decay
  setInterval(()=>{
    for(let i=enemies.length-1;i>=0;i--){ if(enemies[i].health<=0){ removeEnemy(enemies[i]); } }
    if(player.health<=0){ showMessage('You died! Press Respawn.'); controls.unlock(); }
  }, 400);

  // Optional: show debug toggles in console for advanced tweak
  console.log('CONFIG object available in console for tweaking');
  window.CONFIG = CONFIG; window.player = player; window.enemies = enemies;

  </script>
</body>
</html>
